<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Monte Carlo Tau — Point Shooter</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --muted:#9aa4b2; --accent:#7c3aed;
      --ok:#7c3aed; /* inside = violet */
      --bad:#fb7185; /* outside = pink */
      --ink:#e6eef8;
    }
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{background:linear-gradient(180deg,var(--bg),#071226);color:var(--ink);display:flex;align-items:center;justify-content:center;padding:24px;box-sizing:border-box}
    .app{width:100%;max-width:1100px;display:flex;gap:20px;position:relative}
    .panel{background:linear-gradient(180deg,var(--card),#07121a);border-radius:12px;padding:16px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}
    .left{flex:1;display:flex;flex-direction:column;gap:12px}
    .right{width:320px;display:flex;flex-direction:column;gap:12px}
    h1{font-size:18px;margin:0}
    .muted{color:var(--muted)}
    .title{display:flex;align-items:center;gap:12px}
    .hud{display:flex;gap:12px;flex-wrap:wrap}
    .stat{background:linear-gradient(180deg,rgba(255,255,255,0.03),transparent);padding:8px 10px;border-radius:8px;min-width:140px}
    .big{font-size:22px;font-weight:700}
    .controls{display:flex;gap:8px;align-items:center;margin-top:auto}
    button{background:linear-gradient(180deg,#122433,#0a2a3d);color:var(--ink);border:1px solid rgba(255,255,255,0.05);padding:8px 12px;border-radius:8px;cursor:pointer}
    button.primary{background:linear-gradient(180deg,var(--accent),#5b21b6);box-shadow:0 6px 18px rgba(124,58,237,0.18)}
    button:hover{opacity:.9}
    canvas{width:100%;height:calc(100vw * 0.6);max-height:720px;background:linear-gradient(180deg,#081019,#06101a);border-radius:8px;display:block}
    .legend{display:flex;gap:10px;align-items:center}
    .dot{width:10px;height:10px;border-radius:50%}
    .fps{position:absolute;bottom:8px;right:12px;font-size:11px;color:rgba(255,255,255,0.32)}
    .canvasWrap{position:relative}
    .overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(2,6,23,0.7); backdrop-filter:blur(4px); border-radius:12px; z-index:10;
    }
    .overlayCard{
      background:linear-gradient(180deg,var(--card),#0a1220);
      border:1px solid rgba(255,255,255,0.06);
      padding:24px; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.4); max-width:560px; text-align:center;
    }
    .overlayRow{display:flex;gap:10px;justify-content:center;align-items:center;margin-top:10px}
    .input{
      background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.08);
      color:var(--ink); padding:8px 10px; border-radius:8px; outline:none; min-width:200px;
    }
    .hl{font-weight:700;color:var(--accent)}
    .hidden{display:none}
    ol.hs{margin:8px 0 0 20px; padding:0}
    ol.hs li{margin:4px 0; color:var(--muted)}
    .hs-line{display:flex;justify-content:space-between;gap:8px}
    .hs-name{max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .small{font-size:12px;color:var(--muted)}
    @media (max-width:900px){.app{flex-direction:column}.right{width:100%}canvas{height:60vw}}
  </style>
</head>
<body>
  <div class="app">
    <!-- START / END OVERLAYS -->
    <div id="startOverlay" class="overlay">
      <div class="overlayCard">
        <h2 style="margin:0 0 8px">Monte Carlo Tau — Point Shooter</h2>
        <p class="muted" style="margin:0 0 10px">
          Goal: get as close as possible to <b>τ = 2π ≈ 6.283185</b> in <b>30 seconds</b>.<br/>
          Click inside the square to drop points. Balance inside/outside density.
        </p>
        <div class="legend" style="justify-content:center;margin:8px 0 12px">
          <span class="dot" style="background:var(--ok)"></span><span class="muted">inside circle</span>
          <span style="width:12px"></span>
          <span class="dot" style="background:var(--bad)"></span><span class="muted">outside</span>
        </div>
        <div class="overlayRow">
          <label class="small">Name (optional):</label>
          <input id="nameInput" class="input" placeholder="Player" maxlength="24"/>
        </div>
        <div class="overlayRow">
          <button id="startBtn" class="primary">Start (30s)</button>
        </div>
      </div>
    </div>

    <div id="endOverlay" class="overlay hidden">
      <div class="overlayCard">
        <h2 style="margin:0 0 8px">Time!</h2>
        <div class="muted">Your result</div>
        <div style="font-size:26px;font-weight:700;margin:6px 0">τ_est = <span id="finalTau">-</span></div>
        <div class="muted">Absolute error |τ − 2π| = <span id="finalErr">-</span></div>
        <div class="muted" style="margin-top:6px">Inside / Total: <span id="finalCounts">0 / 0</span></div>
        <div class="muted" style="margin-top:6px">Rank: <span id="finalRank">-</span></div>
        <div style="margin-top:14px;display:flex;gap:10px;justify-content:center">
          <button id="restartBtn" class="primary">Restart</button>
          <button id="menuBtn">Back to Menu</button>
        </div>
      </div>
    </div>

    <div class="left panel">
      <div class="title">
        <h1>Monte Carlo Tau — Point Shooter</h1>
        <div style="margin-left:auto" class="muted">Minimize |τ_est − 2π| within 30s</div>
      </div>

      <div class="hud">
        <div class="stat">
          <div class="muted">τ estimate</div>
          <div id="tau" class="big">-</div>
        </div>
        <div class="stat">
          <div class="muted">Absolute error</div>
          <div id="error" class="big">-</div>
        </div>
        <div class="stat">
          <div class="muted">Inside / Total</div>
          <div id="counts" class="big">0 / 0</div>
        </div>
        <div class="stat">
          <div class="muted">Time</div>
          <div id="time" class="big">30.0s</div>
        </div>
      </div>

      <div class="canvasWrap">
        <canvas id="c"></canvas>
        <div id="fps" class="fps"></div>
      </div>

      <div class="legend">
        <span class="dot" style="background:var(--ok)"></span>
        <span class="muted">inside</span>
        <span style="width:12px"></span>
        <span class="dot" style="background:var(--bad)"></span>
        <span class="muted">outside</span>
      </div>

      <div class="controls">
        <button id="resetBtn">Reset</button>
        <button id="saveBtn">Save Snapshot</button>
        <button id="soundBtn">Sound: On</button>
        <span class="muted" style="margin-left:auto">Tip: ensure both inside and outside hits.</span>
      </div>
    </div>

    <div class="right panel">
      <div class="stat">
        <div class="muted">Rules</div>
        <ul class="muted" style="margin:8px 0 0 18px;line-height:1.4">
          <li>Click inside the square to drop a point.</li>
          <li>Round time: <b>30 seconds</b>.</li>
          <li>Estimate: τ ≈ 8 · (inside / total).</li>
          <li>Goal: minimize |τ_est − 2π| (lower is better).</li>
        </ul>
      </div>

      <div class="stat">
        <div class="muted" style="display:flex;align-items:center;gap:8px">
          <span>Highscores (closest to τ)</span>
          <button id="clearHS" style="margin-left:auto">Clear</button>
        </div>
        <ol id="hsList" class="hs"></ol>
        <div class="small" style="margin-top:6px">Stored locally in your browser.</div>
      </div>
    </div>
  </div>

  <script>
    // ---------- Canvas & DPR ----------
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false });
    const fpsEl = document.getElementById('fps');
    let DPR = 1;

    function resize() {
      DPR = Math.min(window.devicePixelRatio || 1, 2);
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * DPR);
      canvas.height = Math.floor(rect.height * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0); // draw in CSS px
      drawAll();
    }
    window.addEventListener('resize', resize);

    // ---------- Geometry helpers ----------
    function getCanvasRect() { return canvas.getBoundingClientRect(); }
    function centerAndScale() {
      const r = getCanvasRect(), w = r.width, h = r.height;
      const s = 0.5 * Math.min(w,h);
      return { cx: 0.5*w, cy: 0.5*h, s, w, h };
    }
    function fromCanvas(x,y) {
      const {cx, cy, s} = centerAndScale();
      return [(x - cx)/s, -(y - cy)/s];
    }

    // ---------- Game state ----------
    const TWO_PI = Math.PI * 2;
    const ROUND_TIME = 30.0; // seconds

    const tauEl = document.getElementById('tau');
    const errEl = document.getElementById('error');
    const countsEl = document.getElementById('counts');
    const timeEl = document.getElementById('time');
    const saveBtn = document.getElementById('saveBtn');
    const resetBtn = document.getElementById('resetBtn');
    const soundBtn = document.getElementById('soundBtn');

    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');
    const nameInput = document.getElementById('nameInput');
    const endOverlay = document.getElementById('endOverlay');
    const restartBtn = document.getElementById('restartBtn');
    const menuBtn = document.getElementById('menuBtn');
    const finalTauEl = document.getElementById('finalTau');
    const finalErrEl = document.getElementById('finalErr');
    const finalCountsEl = document.getElementById('finalCounts');
    const finalRankEl = document.getElementById('finalRank');

    let running = false;
    let timeLeft = ROUND_TIME;
    let lastTS = 0;
    let total = 0, inside = 0;

    // shots for visual feedback
    const shots = []; // {x,y,inside,life}

    // ---------- Highscores ----------
    const HS_KEY = 'tauPointShooterHighscores';
    const hsListEl = document.getElementById('hsList');
    const clearHSEl = document.getElementById('clearHS');

    function loadScores(){ try { return JSON.parse(localStorage.getItem(HS_KEY) || '[]'); } catch { return []; } }
    function saveScores(list){ localStorage.setItem(HS_KEY, JSON.stringify(list)); }
    function addScore(entry){
      const arr = loadScores();
      arr.push(entry);
      arr.sort((a,b) => a.err - b.err); // lower error is better
      const rank = arr.findIndex(x => x === entry) + 1;
      saveScores(arr.slice(0,10));
      return { rank, list: arr.slice(0,10) };
    }
    function renderScores(){
      const arr = loadScores();
      hsListEl.innerHTML = '';
      if (!arr.length){
        const li = document.createElement('li');
        li.textContent = 'No scores yet — be the first!';
        hsListEl.appendChild(li);
        return;
      }
      arr.forEach((s, i) => {
        const li = document.createElement('li');
        const name = s.name && s.name.trim() ? s.name.trim() : 'Player';
        li.innerHTML = `
          <div class="hs-line">
            <span class="hs-name">${i+1}. ${name}</span>
            <span>τ=${s.tau.toFixed(6)}</span>
            <span>err=${s.err.toFixed(6)}</span>
          </div>
          <div class="small">${s.inside}/${s.total} • ${new Date(s.ts).toLocaleString()}</div>
        `;
        hsListEl.appendChild(li);
      });
    }
    clearHSEl.addEventListener('click', () => {
      localStorage.removeItem(HS_KEY);
      renderScores();
    });

    // ---------- Audio (beeps) ----------
    const ACtor = (window.AudioContext || window.webkitAudioContext);
    const ACtx = ACtor ? new ACtor() : null;
    let SOUND_ON = true;

    async function ensureAudio(){
      if (ACtx && ACtx.state === 'suspended') {
        try { await ACtx.resume(); } catch(e) {}
      }
    }
    function beep(freq=440, dur=0.05, gain=0.03){
      if (!ACtx || !SOUND_ON) return;
      const t0 = ACtx.currentTime;
      const osc = ACtx.createOscillator();
      const g = ACtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      g.gain.value = gain;
      osc.connect(g).connect(ACtx.destination);
      osc.start(t0);
      osc.stop(t0 + dur);
    }

    soundBtn.addEventListener('click', async () => {
      SOUND_ON = !SOUND_ON;
      soundBtn.textContent = `Sound: ${SOUND_ON ? 'On' : 'Off'}`;
      if (SOUND_ON) await ensureAudio();
    });

    // ---------- Drawing ----------
    function drawBackground() {
      const r = getCanvasRect();
      ctx.fillStyle = '#06101a';
      ctx.fillRect(0,0,r.width,r.height);
    }
    function drawBoard() {
      const {cx, cy, s} = centerAndScale();
      // square
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 2;
      ctx.strokeRect(cx - s, cy - s, 2*s, 2*s);

      // circle
      ctx.beginPath();
      ctx.arc(cx, cy, s, 0, Math.PI*2);
      const grad = ctx.createRadialGradient(cx,cy,s*0.1, cx,cy,s);
      grad.addColorStop(0,'rgba(124,58,237,0.06)');
      grad.addColorStop(1,'rgba(2,6,23,0)');
      ctx.fillStyle = grad; ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.lineWidth = 1.5; ctx.stroke();

      // axes (subtle)
      ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(cx - s, cy); ctx.lineTo(cx + s, cy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx, cy - s); ctx.lineTo(cx, cy + s); ctx.stroke();
    }
    function drawShots(dt) {
      for (let i = shots.length - 1; i >= 0; i--) {
        const p = shots[i];
        p.life -= dt;
        if (p.life <= 0) { shots.splice(i,1); continue; }
        ctx.globalAlpha = Math.max(0, p.life);
        ctx.fillStyle = p.inside ? '#7c3aed' : '#fb7185'; // violet & pink
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
        ctx.globalAlpha = 1;
      }
    }
    function drawAll() {
      drawBackground();
      drawBoard();
      drawShots(0);
    }

    // ---------- HUD ----------
    function currentTau(){ return total > 0 ? 8 * (inside / total) : NaN; }
    function currentErr(){ const t = currentTau(); return isNaN(t) ? NaN : Math.abs(t - TWO_PI); }

    function updateHUD() {
      const tau = currentTau();
      const err = currentErr();
      tauEl.textContent = isNaN(tau) ? '-' : tau.toFixed(6);
      errEl.textContent = isNaN(err) ? '-' : err.toFixed(6);
      countsEl.textContent = `${inside} / ${total}`;
      timeEl.textContent = `${timeLeft.toFixed(1)}s`;
    }

    // ---------- Interaction ----------
    canvas.addEventListener('click', (e) => {
      if (!running) return;
      const rect = getCanvasRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const {cx, cy, s} = centerAndScale();
      if (x < cx - s || x > cx + s || y < cy - s || y > cy + s) return;

      const [nx, ny] = fromCanvas(x, y);
      const hit = (nx*nx + ny*ny) <= 1.0;

      total += 1;
      if (hit) { inside += 1; beep(660, 0.04, 0.04); }  // inside: higher beep
      else     { beep(220, 0.06, 0.035); }              // outside: lower beep

      shots.push({ x, y, inside: hit, life: 1.0 });
      updateHUD();
    });

    // ---------- Game loop ----------
    let rafId = null;
    let lastFpsTS = performance.now(), fpsCount = 0;
    function loop(ts) {
      if (!lastTS) lastTS = ts;
      const dt = Math.min(0.05, (ts - lastTS)/1000);
      lastTS = ts;

      if (running) {
        timeLeft = Math.max(0, timeLeft - dt);
        if (timeLeft <= 0) {
          running = false;
          showEndAndRecord();
        }
      }

      drawBackground();
      drawBoard();
      drawShots(dt);
      updateHUD();

      // FPS
      fpsCount++;
      if (ts - lastFpsTS >= 1000) {
        const fps = Math.round((fpsCount * 1000) / (ts - lastFpsTS));
        fpsEl.textContent = `${fps} FPS`;
        fpsCount = 0; lastFpsTS = ts;
      }

      rafId = requestAnimationFrame(loop);
    }

    // ---------- Overlays & Controls ----------
    async function startGame() {
      await ensureAudio();         // unlock audio on user gesture (Start)
      resetState();
      startOverlay.classList.add('hidden');
      endOverlay.classList.add('hidden');
      running = true;
    }

    function resetState() {
      running = false;
      timeLeft = ROUND_TIME;
      total = 0; inside = 0;
      shots.length = 0;
      drawAll(); updateHUD();
    }

    function showEndAndRecord() {
      const tau = currentTau();
      const err = currentErr();

      finalTauEl.textContent = isNaN(tau) ? '-' : tau.toFixed(6);
      finalErrEl.textContent = isNaN(err) ? '-' : err.toFixed(6);
      finalCountsEl.textContent = `${inside} / ${total}`;

      // record score if valid
      let rankText = '—';
      if (!isNaN(err)) {
        const entry = {
          name: (nameInput.value || 'Player').slice(0,24),
          tau, err, inside, total,
          ts: Date.now()
        };
        const { rank } = addScore(entry);
        renderScores();
        rankText = `#${rank}`;
      }
      finalRankEl.textContent = rankText;
      endOverlay.classList.remove('hidden');
    }

    document.getElementById('saveBtn').addEventListener('click', () => {
      const rect = getCanvasRect();
      const out = document.createElement('canvas');
      out.width = Math.floor(rect.width * DPR);
      out.height = Math.floor(rect.height * DPR);
      const octx = out.getContext('2d');
      octx.setTransform(DPR,0,0,DPR,0,0);
      octx.drawImage(canvas, 0, 0, rect.width, rect.height);
      const tau = currentTau();
      const err = currentErr();
      octx.font = '16px system-ui,Segoe UI,Roboto,Arial';
      octx.fillStyle = 'rgba(255,255,255,0.9)';
      octx.fillText(`τ ≈ ${isNaN(tau) ? '-' : tau.toFixed(6)} | error=${isNaN(err)?'-':err.toFixed(6)} | inside/total=${inside}/${total}`, 16, 28);
      const a = document.createElement('a');
      a.href = out.toDataURL('image/png'); a.download = `tau-point-shooter-${Date.now()}.png`; a.click();
    });

    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('restartBtn').addEventListener('click', () => {
      endOverlay.classList.add('hidden');
      startGame();
    });
    document.getElementById('menuBtn').addEventListener('click', () => {
      endOverlay.classList.add('hidden');
      startOverlay.classList.remove('hidden');
      resetState();
    });
    resetBtn.addEventListener('click', () => {
      startOverlay.classList.remove('hidden');
      endOverlay.classList.add('hidden');
      resetState();
    });

    // ---------- Init ----------
    resize();
    resetState();
    renderScores();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
